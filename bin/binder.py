import glob
import sys
from typing import Any
import os.path


class Log:
    @staticmethod
    def _write(prefix: str, msg: str, *args: Any, file=None) -> None:
        line = f"[{prefix}] {msg % args if args else msg}"
        print(line, file=file or sys.stderr, flush=True)

    @staticmethod
    def info(msg: str, *args: Any) -> None:
        Log._write("INFO", msg, *args)

    @staticmethod
    def warn(msg: str, *args: Any) -> None:
        Log._write("WARN", msg, *args, file=sys.stderr)

    @staticmethod
    def error(msg: str, *args: Any) -> None:
        Log._write("ERROR", msg, *args, file=sys.stderr)

    @staticmethod
    def fatal(msg: str, *args: Any) -> None:
        Log._write("FATAL", msg, *args, file=sys.stderr)
        sys.exit(1)


# Short aliases
log = Log.info
warn = Log.warn
error = Log.error
fatal = Log.fatal


TAB = " " * 4
FUNC = "@func"
VAR = "@var"
STATICVAR = "@staticvar"
STATICFUNC = "@staticfunc"
PROP = "@prop"
CONST = "@const"
EXPORT = "@export"
ENUM = "@enum"
STRUCT = "@struct"

EXIT_SUCCESS = 0
EXIT_FAILURE = 1


HEADER_H = """
// bind.h — AUTOGENERATED

#pragma once

// AUTOGENERATED — DO NOT EDIT

#include "squirrel.h"
#include "sqrat.h"

class CTreeRat;

void registerBinding(CTreeRat & rat);
void registerGlobal(CTreeRat & rat);
void injectSelectBindings(HSQUIRRELVM vm, Sqrat::Table &sandbox);
""".strip()

REGISTER_BINDER_HEAD = """
void registerBinding(CTreeRat & rat)
{
    HSQUIRRELVM vm = rat.vm();
    BinderMap registry;

"""

REGISTER_BINDER_TAIL = """
    Sqrat::Table root = Sqrat::RootTable(rat.vm());

    for (const auto &[name, binder] : registry)
    {
        LOGI("Binding: %s", name.c_str());
        binder(root);
    }

}
"""


class Structs:
    fields: dict[list] = {}
    ctr: dict[str] = {}


class Tag:
    op: str
    alias: str
    args: list[str]
    names: list[str]

    def __init__(self):
        self.clear()

    def clear(self) -> None:
        self.op = ""
        self.alias = ""
        self.args = []
        self.names = []


def grab_vars(
    tag: Tag,
    binding: dict[str, list],
    class_name: str,
    line: str,
    line_num: int,
) -> None:
    b = line.split(";", 1)[0].split("=")
    var = [b for b in b[0].split(" ") if b][-1]
    var = var.replace("&", "").replace("*", "")

    if not var:
        tag.clear()
        error(f"no var found on line {line_num}: {line}")
        return

    binding[class_name].append([tag.op, var, tag.alias if tag.alias else var])


def grab_func(
    tag: Tag,
    binding: dict[str, list],
    class_name: str,
    parts: list[str],
    line: str,
    line_num: int,
) -> bool:
    # Find function signature
    sig_token = next((p for p in parts if "(" in p), None)
    if not sig_token:
        error(f"no function signature on line {line_num}: {line}")
        return False
    fn = (
        sig_token.split("(", 1)[0]
        .split("::")[-1]
        .strip()
        .replace("&", "")
        .replace("*", "")
    )

    params = [tag.op, fn, tag.alias if tag.alias else fn, tag.args]
    binding[class_name].append(params)
    return True


def get_tag_line(tag: Tag, op: str, line: str, line_num: int) -> bool:
    tag.clear()
    a = line.split(op, 1)
    if len(a) != 2:
        error(f"can't find {op} on line {line_num}: {line}")
        return False
    tag.op = op

    a = a[1].split("|", 1)
    if len(a) == 2:
        tag.args = a[1]

    a = a[0].split(":")
    if len(a) != 1:
        tag.alias = a[1]
        tag.names = a[1:]

    return True


def grab_prop(
    tag: Tag,
    binding: dict[str, list],
    class_name: str,
    line: str,
    line_num: int,
    basename: str,
) -> None:
    print_error = lambda err_msg: error(
        f"{err_msg} [{basename}] on line {line_num}: `{line}`"
    )

    get_tag_line(tag, PROP, line, line_num)
    parts = tag.alias.split(",")
    tag.clear()
    if not parts:
        print_error(f"Malformed {PROP}")
    elif not (2 <= len(parts) <= 3):
        print_error(f"{PROP} expects getter,setter[,canSet]")
    else:
        prop_name = parts[0]
        getter = parts[1]
        setter = parts[2] if len(parts) == 3 else ""
        binding[class_name].append([PROP, prop_name, getter, setter])


def grab_enums(
    tag: Tag,
    enums: dict[list],
    class_name: str,
    parts: list[str],
    enum_group: str,
    line: str,
    line_num: int,
    basename: str,
) -> str:
    print_error = lambda err_msg: error(
        f"{err_msg} [{basename}] on line {line_num}: `{line}`"
    )

    if tag.op == ENUM and not enum_group:
        if "enum" not in parts:
            tag.clear()
            print_error("missing enum declaration")
            return ""
        a = line.strip().split("//", 1)
        a = [x.strip() for x in a[0].split("enum") if x.strip()]
        enum_group = a[0].split(":")[0].strip()
        if not enum_group:
            tag.clear()
            print_error("anonymous enums not allowed on line")
            return ""
        if enum_group not in enums:
            enums[enum_group] = []
        else:
            tag.clear()
            print_error(f"enum group duplicated `{enum_group}`")
            enum_group = ""
    elif tag.op == ENUM and enum_group:
        if line == "{":
            return enum_group
        elif "};" in parts:
            enum_group = ""
            tag.clear()
        else:
            name = parts[0].split(",")[0]
            enums[enum_group].append([name, f"{class_name}::{enum_group}::{name}"])
    return enum_group


def grab_struct(
    tag: Tag,
    class_name: str,
    struct_name: str,
    structs: Structs,
    parts: list[str],
    line: str,
    line_num: int,
    basename: str,
) -> str:
    print_error = lambda err_msg: error(
        f"{err_msg} [{basename}] on line {line_num}: `{line}`"
    )
    if tag.op == STRUCT and not struct_name:
        if "typedef" in parts:
            tag.clear()
            print_error("typedef not supported")
            return ""
        a = line.strip().split("//", 1)
        a = [x.strip() for x in a[0].split("struct") if x.strip()]
        struct_name = a[0].split(":")[0].strip()
        if not struct_name:
            tag.clear()
            print_error("anonymous struct not allowed on line")
            return ""
        if struct_name not in structs.fields:
            structs.fields[struct_name] = []
            structs.ctr[struct_name] = tag.args
        else:
            tag.clear()
            print_error(f"struct duplicated `{struct_name}`")
            struct_name = ""
    elif tag.op == STRUCT and struct_name:
        if line == "{":
            return struct_name
        elif "};" in parts:
            tag.clear()
            struct_name = ""
        elif ";" not in line:
            tag.clear()
            struct_name = ""
        else:
            name = parts[-1].split(";")[0]
            structs.fields[struct_name].append(
                [
                    tag.alias if tag.alias else name,
                    f"{class_name}::{struct_name}::{name}",
                ]
            )
    return struct_name


def scan_file(
    path: str,
    headers: set[str],
    binding: dict[str, list],
    exports: list[list[str]],
    enums: dict[list],
    structs: Structs,
) -> None:

    basename = os.path.basename(path)
    if basename == "bind.h":
        return

    ALL_CLASS_TAGS = [FUNC, VAR, PROP, CONST, STATICVAR, STATICFUNC]
    ALL_TAGS = set(ALL_CLASS_TAGS + [ENUM, STRUCT, EXPORT])
    with open(path) as sfile:
        struct_name = ""
        enum_group = ""
        class_name = ""
        line_num = 0
        print_error = lambda err_msg: error(
            f"{err_msg} [{basename}] on line {line_num}: `{line}`"
        )

        tag: Tag = Tag()
        for line in sfile:
            line_num += 1
            line = line.strip()
            if not line:
                continue
            parts: list[str] = [p for p in line.split() if p]

            if tag.op:
                headers.add(basename)

            # Detect class
            if any(tag in line for tag in ALL_CLASS_TAGS) and not class_name:
                print_error("class_name missing")
                continue

            results = [
                u for u in [p.startswith(tag) for tag in ALL_TAGS for p in parts] if u
            ]
            if len(results) > 1:
                print_error("multiple tags found")
                continue
            found = [
                op
                for op in [EXPORT, FUNC, STATICFUNC, VAR, STATICVAR, CONST]
                if op in line
            ]
            if len(found) > 1:
                print_error("multiple conflicting tags")
                continue
            elif found:
                get_tag_line(tag, found[0], line, line_num)
                continue

            # class
            if line.startswith("class ") and not line.endswith(";"):
                class_name = (
                    line.split("class", 1)[1]
                    .split()[0]
                    .split(":")[0]
                    .split("{")[0]
                    .strip()
                )
                if not class_name in binding:
                    binding[class_name] = []
                continue

            # @export
            elif tag.op == EXPORT:
                fn_sig = [p for p in parts if "(" in p]
                if not fn_sig:
                    print_error(f"can't find {EXPORT} name")
                    continue
                fn = fn_sig[0].split("(", 1)[0]
                exports.append([fn, tag.alias] if tag.alias else [fn, fn])

            # @enum
            elif ENUM in line:
                get_tag_line(tag, ENUM, line, line_num)
                enum_group = ""
            elif tag.op == ENUM:
                enum_group = grab_enums(
                    tag,
                    enums,
                    class_name,
                    parts,
                    enum_group,
                    line,
                    line_num,
                    basename,
                )

            elif STRUCT in line:
                get_tag_line(tag, STRUCT, line, line_num)
            elif tag.op == STRUCT:
                struct_name = grab_struct(
                    tag,
                    class_name,
                    struct_name,
                    structs,
                    parts,
                    line,
                    line_num,
                    basename,
                )

            elif PROP in line:
                grab_prop(tag, binding, class_name, line, line_num, basename)

            elif tag.op in [FUNC, STATICFUNC]:
                grab_func(tag, binding, class_name, parts, line, line_num)
                tag.clear()

            elif tag.op in [VAR, STATICVAR, CONST]:
                grab_vars(tag, binding, class_name, line, line_num)
                tag.clear()


def compose_cpp_header(headers):
    headers_sorted = list(headers)
    headers_sorted.sort()
    lines = (
        [
            """
// bind.cpp — AUTOGENERATED

// AUTOGENERATED — DO NOT EDIT"
#include <unordered_map>
#include <string>
#include <array>
#include <sqrat.h>
#include "squirrel.h"

#include "bind.h"
#include "treerat.h"
""".strip(),
        ]
        + [f'#include "{h}"' for h in headers_sorted]
        + [
            """using Binder = std::function<void(Sqrat::Table &)>;
using BinderMap = std::unordered_map<std::string, Binder>;""",
            "",
        ]
    )
    return lines


def compose_class_binding(binding: dict[str, list], lines: list[str]) -> None:
    for class_name, binded in binding.items():
        if not binded:
            continue
        lines += [
            f"""
    registry["{class_name}"] = [](Sqrat::Table &target)
    {{
        auto vm = target.GetVM();
        auto cls = Sqrat::Class<{class_name}>(vm, "{class_name}")
""",
            f"{TAB*2}// === {class_name} Class ===",
            f"{TAB*3}.Ctor<>()",
        ]

        # member functions, variables, consts, etc
        for b in binded:
            op = b[0]
            if op == FUNC:
                ref = f"&{class_name}::{b[1]}"
                if b[3]:
                    a = b[3].split(",")
                    ref = f"static_cast<{a[0]} ({class_name}::*)({', '.join(a[1:])})>(&{class_name}::{b[1]})"
                lines += [f'{TAB*3}.Func("{b[2]}", {ref})']
            if op == STATICFUNC:
                ref = f"&{class_name}::{b[1]}"
                if b[3]:
                    a = b[3].split(",")
                    ref = f"static_cast<{a[0]} (*)({', '.join(a[1:])})>(&{class_name}::{b[1]})"
                lines += [f'{TAB*3}.StaticFunc("{b[2]}", {ref})']
            elif op == VAR:
                lines += [f'{TAB*3}.Var("{b[2]}", &{class_name}::{b[1]})']
            elif op == STATICVAR:
                lines += [f'{TAB*3}.StaticVar("{b[2]}", &{class_name}::{b[1]})']
            elif op == CONST:
                lines += [f'{TAB*3}.ConstVar("{b[2]}", &{class_name}::{b[1]})']
            elif op == PROP:
                getter, setter = b[2], b[3]
                if setter:
                    lines += [
                        f'{TAB*3}.Prop("{b[1]}", &{class_name}::{getter}, &{class_name}::{setter})'
                    ]
                else:
                    lines += [f'{TAB*2}.Prop("{b[1]}", &{class_name}::{getter})']

        lines[-1] = lines[-1] + ";"
        lines += [f'{TAB*2}target.Bind("{class_name}", cls);', f"{TAB}}};"]


def compose_enums(enums: dict[list], lines: list[str]) -> None:
    for group_name, names in enums.items():
        if not names:
            continue

        lines += [
            f"{TAB*2}// === {group_name} Enum ===",
            f'    registry["{group_name}"] = [](Sqrat::Table &target)',
            f"{TAB}{{",
            f"{TAB*2}auto vm = target.GetVM();",
            f"{TAB*2}auto ct = Sqrat::ConstTable(vm)",
        ]
        for name in names:
            naked, ref = name
            lines += [f'{TAB*3}.Const("{naked}", {ref})']

        lines[-1] += ";"
        lines += [f'{TAB*2}target.Bind("{group_name}", ct);', f"{TAB}}};"]


def compose_structs(structs: Structs, lines: list[str]) -> None:

    for struct_name, names in structs.fields.items():
        if not names:
            continue

        lines += [""]
        lines += [f"{TAB}// === {struct_name} Struct ==="]
        lines += [
            f'{TAB}registry["{struct_name}"] = [](Sqrat::Table &target)',
            f"{TAB}{{",
            f"{TAB*2}auto vm = target.GetVM();",
            f'{TAB*2}auto cls = Sqrat::Class<{struct_name}>(vm, "{struct_name}")',
        ]
        ctr = structs.ctr[struct_name]

        if ctr:
            args = ", ".join(ctr.split(","))
            lines += [f"{TAB*3}.Ctor<{args}>()"]
        for name in names:
            naked, ref = name
            lines += [f'{TAB*3}.Var("{naked}", &{ref})']

        lines[-1] += ";"
        lines += [f'{TAB*2}target.Bind("{struct_name}", cls);', f"{TAB}}};"]


def compose_global_exports(lines: list[str], exports: list[list[str]]):
    lines += [
        "",
        """
void registerGlobal(CTreeRat & rat)
{
        """.strip(),
    ]

    for ex in exports:
        lines += [f"""{TAB}rat.registerFn("{ex[1]}", {ex[0]});"""]

    lines += [
        "}",
    ]


def compose_inject_bindings(lines: list[str], config: dict[str, list[str]]):

    count_items = len(config["mod-whitelist"]) if "mod-whitelist" in config else 0
    list_values = (
        f",\n{TAB*2}".join([f'"{item}"' for item in config["mod-whitelist"]])
        if count_items
        else ""
    )

    lines += [
        "",
        f"""

void injectSelectBindings(HSQUIRRELVM vm, Sqrat::Table &sandbox)
{{
    const Sqrat::Table root = Sqrat::RootTable(vm);
    const std::array<std::string, {count_items}> whiteList = {{
        {list_values}
    }};

    for (const auto& name : whiteList) {{
        auto slot = root.GetSlot(name.c_str());
        if (slot.IsNull()) {{
            LOGW("injectSelectBindings: '%s' not found in root table", name.c_str());
            continue;
        }}
        sandbox.SetValue(name.c_str(), slot);
    }}
}}

""".strip(),
        "",
    ]


def write_cpp(
    dest: str,
    headers: list[str],
    binding: dict[str, list],
    exports: list[list[str]],
    enums: dict[list],
    structs: Structs,
    config: dict[str, list],
) -> None:

    with open(dest, "w") as tfile:

        #####################################################
        # bindings
        lines = compose_cpp_header(headers)

        lines += [REGISTER_BINDER_HEAD]

        # class bindings
        compose_class_binding(binding, lines)

        # enums
        compose_enums(enums, lines)

        # structs
        compose_structs(structs, lines)

        lines += [REGISTER_BINDER_TAIL]

        compose_global_exports(lines, exports)
        compose_inject_bindings(lines, config)

        # write to file
        tfile.write("\n".join(lines))


# write header file
def write_header(dest) -> None:
    with open(dest, "w") as tfile:
        tfile.write(HEADER_H)


def parse_config(config_path) -> dict[str, list[str]] | None:

    if not os.path.isfile(config_path):
        return None

    config: dict[str, list[str]] = dict()
    with open(config_path) as sfile:
        line_num = 0
        section = ""
        for line in sfile:
            line_num += 1
            line = line.strip()
            a = line.split("#", 1)
            if len(a) == 2:
                line = a[0].strip()
            if not line:
                continue
            if line[0] == "[" and line[-1] == "]":
                section = line[1:-1]
            elif line[0] == "[":
                error(f"missing section terminator on line {line_num}: {line}")
                section = line[1:-1]
            elif section:
                if section not in config:
                    config[section] = []
                config[section].append(line)
            else:
                error(f"unbound data on line {line_num}: {line}")
    return config


def main():

    if len(sys.argv) > 1:
        config_path = sys.argv[1]
    else:
        config_path = "config/binder.conf"

    config = parse_config(config_path)
    if not config:
        fatal(f"cannot open config: {config_path}")
    if "sources" not in config or not config["sources"]:
        fatal("no source defined")
    log(config)

    headers = set()
    binding = {}
    exports = []
    enums = {}
    structs = Structs
    search_path = config["sources"][0]
    for path in glob.glob(search_path):
        scan_file(path, headers, binding, exports, enums, structs)

    write_cpp("src/bind.cpp", headers, binding, exports, enums, structs, config)
    write_header("src/bind.h")

    exit(EXIT_SUCCESS)


main()
